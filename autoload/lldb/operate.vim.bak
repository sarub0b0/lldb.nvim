function! lldb#operate#init()
    let g:lldb#operate#buftype = ''
    let g:lldb#operate#is_breakpoints = v:false
    let s:threads_done = v:true
    let s:variables_done = v:true
    let s:run_done = v:true
    let s:breakpoints_done = v:true
    let s:next_done = v:true
    " let s:opt = {'out_io': 'buffer', 'out_name': 'lldb'}
endfunction

function! lldb#operate#start(target) abort

    if g:lldb#ui#created == 0
        call lldb#ui#create_panes()
        let g:lldb#ui#created = 1
    endif

    let g:lldb#operate#buftype = 'lldb'
    " let s:job = jobstart(['lldb'], s:opt)
    " if a:target ==# ''
    " let s:job = jobstart(['lldb'], extend({'shell': 'lldb'}, s:callbacks))
    " else
    let s:job = jobstart(['lldb', a:target], extend({'shell': 'lldb'}, s:callbacks))
    " endif
endfunction

function! lldb#operate#stop() abort
    let g:lldb#operate#buftype = 'lldb'
    call jobstop(s:job)
endfunction

function! lldb#operate#run() abort
    let g:lldb#operate#buftype = 'lldb'
    let s:run_done = v:false
    call lldb#operate#send('run')
    if g:lldb#operate#is_breakpoints == v:true
        let s:threads_done = v:false
        let s:variables_done = v:false
    endif
endfunction

function! lldb#operate#send(cmd) abort
    call chansend(s:job, a:cmd . "\n")
endfunction

function! lldb#operate#backtrace() abort
    let g:lldb#operate#buftype = 'backtrace'
    let s:backtrace_done = v:false
    " call s:buffer_clean(g:lldb#operate#buftype)
    call lldb#operate#send('backtrace')
endfunction

function! lldb#operate#variables() abort
    let g:lldb#operate#buftype = 'lldb'
    let s:variables_done = v:false
    " call s:buffer_clean(g:lldb#operate#buftype)
    call lldb#operate#send('frame variable')
endfunction

function! lldb#operate#breakpoints() abort
    let g:lldb#operate#buftype = 'lldb'
    let s:breakpoints_done = v:false
    " call s:buffer_clean(g:lldb#operate#buftype)
    call lldb#operate#send('breakpoint list')
endfunction

function! lldb#operate#threads() abort
    let g:lldb#operate#buftype = 'lldb'
    let s:threads_done = v:false
    " call s:buffer_clean(g:lldb#operate#buftype)
    call lldb#operate#send('thread list')
endfunction

function! lldb#operate#target(target) abort
    let g:lldb#operate#buftype = 'target'
    call lldb#operate#send('target create ' . a:target)
endfunction

function! lldb#operate#next() abort
    let g:lldb#operate#buftype = 'lldb'
    let g:run_done = v:false
    call lldb#operate#send('next')
    if g:lldb#operate#is_breakpoints == v:true
        let s:threads_done = v:false
        let s:variables_done = v:false
    endif
endfunction

function! lldb#operate#step() abort
    let g:lldb#operate#buftype = 'lldb'
    call lldb#operate#send('step')
    call s:update()
endfunction

function! lldb#operate#continue() abort
    let g:lldb#operate#buftype = 'lldb'
    call lldb#operate#send('continue')
    call s:update()
endfunction

function! s:update()
endfunction

let s:all_msg = []
function! s:on_event(job_id, data, event) dict abort
    let l:str = []
    let l:buftype = g:lldb#operate#buftype
    let l:move_window = "execute bufwinnr(bufnr('" . l:buftype . "')).'wincmd w'"
    execute l:move_window

    " if g:lldb#operate#buftype !=# 'lldb'
    "     call s:buffer_clean(g:lldb#operate#buftype)
    " endif

    let l:str = s:remove_empty(a:data)

    call add(s:all_msg, l:str)
    call join(s:all_msg)


    " call append(line('$'), l:str)

    " echomsg string(l:str)



    if 0 < len(l:str)
        if s:check_run_done(l:str) && s:run_done == v:false
            let s:run_done = v:true
            " call s:post_process(l:buftype)
            echomsg 'run or next done'
            echomsg string(s:all_msg)
            call append(line('$'), string(s:all_msg))
            let s:all_msg = []
        endif

        " if s:check_run_done(l:str) && s:next_done == v:false
        "     let s:next_done = v:true
        "     call s:post_process(l:buftype)
        "     echomsg 'next done'
        " endif

        if s:check_threads_done(l:str) && s:threads_done == v:false
            let s:threads_done = v:true
            " call s:post_process(l:buftype)
            echomsg 'threads done'
            echomsg string(s:all_msg)
            call append(line('$'), string(s:all_msg))
            let s:all_msg = []
        endif

        if s:check_variables_done(l:str) && s:variables_done == v:false
            let s:variables_done = v:true
            " call s:post_process(l:buftype)
            echomsg 'variable done'

            echomsg string(s:all_msg)
            call append(line('$'), string(s:all_msg))

            let s:all_msg = []
        endif

        if s:check_breakpoints_done(l:str) && s:breakpoints_done == v:false
            let s:breakpoint_done = v:true
            " call s:post_process(l:buftype)
            echomsg 'breakpoint done'
            echomsg string(s:all_msg)
            call append(line('$'), string(s:all_msg))
            let s:all_msg = []
        endif
    endif

    if s:threads_done == v:false && s:run_done == v:true
        call lldb#operate#threads()
    endif

    if s:variables_done == v:false && s:threads_done == v:true
        call lldb#operate#variables()
    endif


endfunction

function! s:list_to_string(list)
    let l:str = string(a:list)

endfunction

function! s:post_process(buftype) abort
    call s:buffer_move(a:buftype)
    if a:buftype !=# 'lldb'
        execute 'g/(lldb)/d'
    endif
    execute 'g/^$/d'
    execute '$'
endfunction

function! s:check_run_done(str) abort
    if g:lldb#operate#is_breakpoints == v:false
        if a:str[-1] =~# 'Process [0-9]* exited .*' || a:str[-1] =~# 'Current executable set to .*'
            echomsg 'check run 1'
            return 1
        endif
    else
        if a:str[-1] =~# 'Target [0-9]*: (.*) stopped'
            echomsg 'check run 2'
            return 1
        endif
    endif
    return 0
endfunction

function! s:check_threads_done(str) abort
    let l:ret = eval(a:str[-1] =~# '\* thread .*')
    return l:ret
endfunction

function! s:check_variables_done(str) abort
    let l:ret = eval(a:str[-1] =~# '(.*) .* = .*')
    return l:ret
endfunction

function! s:check_breakpoints_done(str) abort
    let l:ret = eval(a:str[-1] =~# '.* where = .*')
    return l:ret
endfunction
" let s:callbacks = { 'on_stdout': function('s:on_event'), 'stdout_buffered': v:true }

let s:callbacks = {
            \ 'on_stdout': function('s:on_event'),
            \ 'on_stderr': function('s:on_event'),
            \ 'on_exit': function('s:on_event')
            \ }

function! s:remove_empty(data) abort
    if empty(a:data)
        return ['']
    endif
    let l:ret = []
    for l:v in a:data
        if l:v !=# ''
            call add(l:ret, l:v)
        endif
    endfor

    if empty(l:ret)
        return ['']
    endif
    return l:ret
endfunction

function! s:buffer_clean(buftype) abort
    execute "execute bufwinnr(bufnr('" . a:buftype . "')).'wincmd w'"
    execute '%d'
endfunction

function! s:buffer_move(buftype) abort
    execute "execute bufwinnr(bufnr('" . a:buftype . "')).'wincmd w'"
endfunction
